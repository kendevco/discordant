{
  "name": "discordant_agent_0003",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "discordant-ai-services",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "https://discordant.kendev.co,http://localhost:3001,http://localhost:3000,*"
        }
      },
      "id": "3e68304a-ff77-4a97-a93f-04c0489416b7",
      "name": "Discordant Chat Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1900,
        -60
      ],
      "webhookId": "e7e3c8f2-a8b8-4e7e-3c8f-2a8be7e3c8f2"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT content, memberId as user_id, createdAt as timestamp, 'user' as role FROM message WHERE channelId = '{{ $json.channelId }}' ORDER BY createdAt DESC LIMIT 20"
      },
      "id": "7b3c6606-db7f-418b-a8f1-4e81a6089729",
      "name": "Load Channel History",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 1,
      "position": [
        -1520,
        -80
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "channel_id",
              "value": "={{ $('Input Processor').first().json.channelId }}"
            },
            {
              "key": "channel_history_count",
              "value": "={{ $('Load Channel History').all().length }}"
            },
            {
              "key": "channel_history_preview",
              "value": "={{ JSON.stringify($('Load Channel History').all().slice(0, 3)) }}"
            },
            {
              "key": "last_message_timestamp",
              "value": "={{ $('Load Channel History').all().length > 0 ? $('Load Channel History').all()[0].json.timestamp : 'No messages' }}"
            },
            {
              "key": "conversation_participants",
              "value": "={{ [...new Set($('Load Channel History').all().map(item => item.json.user_id))].join(', ') }}"
            },
            {
              "key": "input_message",
              "value": "={{ $('Input Processor').first().json.input }}"
            },
            {
              "key": "debug_timestamp",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "456fc689-c013-4d75-b1a6-ac7865c0a614",
      "name": "Channel History Debug Data",
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        -1300,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Format Context with cold start resilience\nconsole.log('=== FORMAT CONTEXT NODE DEBUG ===');\nconst startTime = Date.now();\n\ntry {\n  // Get channel history from Discordant message table\n  const channelHistory = $('Load Channel History').all();\n  const inputData = $('Input Processor').first().json;\n  \n  console.log('Channel history items:', channelHistory.length);\n  console.log('Input data keys:', Object.keys(inputData));\n  console.log('Processing time so far:', Date.now() - startTime, 'ms');\n  \n  // Handle cold start scenarios gracefully\n  if (!channelHistory || channelHistory.length === 0) {\n    console.log('WARNING: No channel history found for channel:', inputData.channelId);\n    console.log('This might be due to cold start delays or empty channel');\n  } else {\n    console.log('Sample channel history:', JSON.stringify(channelHistory.slice(0, 2), null, 2));\n  }\n  \n  // Format conversation history from Discordant messages with better error handling\n  let conversationHistory = 'No previous conversation in this channel';\n  \n  try {\n    if (channelHistory && channelHistory.length > 0) {\n      const validMessages = channelHistory.filter(item => {\n        return item.json && \n               item.json.content && \n               typeof item.json.content === 'string' && \n               item.json.content.trim().length > 0;\n      });\n      \n      if (validMessages.length > 0) {\n        conversationHistory = validMessages\n          .reverse()\n          .map(item => `${item.json.user_id}: ${item.json.content}`)\n          .join('\\n\\n');\n      }\n    }\n  } catch (historyError) {\n    console.error('Error processing conversation history:', historyError.message);\n    conversationHistory = 'Error loading conversation history (cold start recovery)';\n  }\n  \n  const now = new Date();\n  const currentDate = now.toISOString().split('T')[0];\n  const currentTime = now.toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  \n  const messageCount = channelHistory ? channelHistory.filter(item => item.json && item.json.content && item.json.content.trim()).length : 0;\n  \n  const result = {\n    ...inputData,\n    conversationHistory,\n    currentDate,\n    currentTime,\n    messageCount,\n    processingTime: Date.now() - startTime,\n    coldStartRecovery: messageCount === 0 && channelHistory && channelHistory.length === 0\n  };\n  \n  console.log('=== FORMAT CONTEXT SUCCESS ===');\n  console.log('Result keys:', Object.keys(result));\n  console.log('Message count:', result.messageCount);\n  console.log('Channel:', inputData.channelId);\n  console.log('Conversation history length:', result.conversationHistory.length);\n  console.log('Total processing time:', result.processingTime, 'ms');\n  \n  return result;\n  \n} catch (error) {\n  console.error('=== FORMAT CONTEXT ERROR ===');\n  console.error('Error details:', error.message);\n  console.error('Error stack:', error.stack);\n  console.error('Processing time before error:', Date.now() - startTime, 'ms');\n  \n  const inputData = $('Input Processor').first().json;\n  return {\n    ...inputData,\n    conversationHistory: 'Channel history temporarily unavailable (cold start/initialization delay)',\n    currentDate: new Date().toISOString().split('T')[0],\n    currentTime: new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' }),\n    messageCount: 0,\n    errorOccurred: true,\n    errorMessage: error.message,\n    processingTime: Date.now() - startTime,\n    coldStartIssue: true\n  };\n}"
      },
      "id": "817c921d-489a-4a38-985d-31f2e996283d",
      "name": "Format Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1300,
        -180
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "returnAll": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Return_All', `Should return all events? Usually true for viewing calendar.`, 'boolean') }}",
        "limit": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Limit', `Maximum number of events to return (e.g., 50)`, 'number') }}",
        "timeMin": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start_Time', `Start date/time in ISO format (e.g., 2025-06-01T00:00:00Z for today)`, 'string') }}",
        "timeMax": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End_Time', `End date/time in ISO format (e.g., 2025-06-08T23:59:59Z for next week)`, 'string') }}",
        "options": {}
      },
      "id": "588cd6b0-eabd-4c8a-9fe2-efc5719ba9f4",
      "name": "View_Calendar_Events",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        -960,
        40
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start_DateTime', `Start date and time in ISO format (e.g., 2025-06-02T15:00:00-04:00)`, 'string') }}",
        "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End_DateTime', `End date and time in ISO format (e.g., 2025-06-02T16:00:00-04:00)`, 'string') }}",
        "additionalFields": {
          "description": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Description', `Optional description or notes for the event`, 'string') }}",
          "location": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Location', `The location of the event (e.g., \"Enterprise Dog Park, Clearwater, FL\")`, 'string') }}",
          "summary": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Title', `The title/name of the event (e.g., \"Enterprise Dog Park Meeting\")`, 'string') }}"
        }
      },
      "id": "dd2d7e2e-8486-4721-a713-9e705fb08f35",
      "name": "Create_New_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        -840,
        40
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID', `The ID of the event to update`, 'string') }}",
        "updateFields": {
          "description": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Description', `Updated description or notes for the event (optional)`, 'string') }}",
          "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_End_DateTime', `New end date and time in ISO format (e.g., 2025-06-02T17:00:00-04:00)`, 'string') }}",
          "location": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Location', `Updated location of the event (optional)`, 'string') }}",
          "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Start_DateTime', `New start date and time in ISO format (e.g., 2025-06-02T16:00:00-04:00)`, 'string') }}",
          "summary": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Title', `Updated title/name of the event (optional)`, 'string') }}"
        }
      },
      "id": "88052a46-2456-4adc-89ea-b3b109173df0",
      "name": "Update_Existing_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        -720,
        40
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID_To_Delete', `The ID of the event to delete`, 'string') }}",
        "options": {}
      },
      "id": "7bcba847-5fb0-470f-af3c-f9315dfd278c",
      "name": "Delete_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        -600,
        40
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "user_message",
              "value": "={{ $('Input Processor').first().json.input }}"
            },
            {
              "key": "user_input",
              "value": "={{ $('Input Processor').first().json.input }}"
            },
            {
              "key": "ai_agent_output",
              "value": "={{ $('AI Agent').first().json.output }}"
            },
            {
              "key": "ai_agent_full",
              "value": "={{ JSON.stringify($('AI Agent').first().json) }}"
            },
            {
              "key": "tools_called",
              "value": "={{ $('AI Agent').first().json.toolCalls ? JSON.stringify($('AI Agent').first().json.toolCalls) : ($('AI Agent').first().json.intermediateSteps ? JSON.stringify($('AI Agent').first().json.intermediateSteps) : ($('AI Agent').first().json.steps ? JSON.stringify($('AI Agent').first().json.steps) : \"Tools called but debug data not captured\")) }}"
            },
            {
              "key": "session_id",
              "value": "={{ $('Input Processor').first().json.sessionId }}"
            },
            {
              "key": "conversation_history",
              "value": "={{ $('Format Context').first().json.conversationHistory || \"No history available\" }}"
            },
            {
              "key": "message_count",
              "value": "={{ $('Format Context').first().json.messageCount || 0 }}"
            },
            {
              "key": "platform",
              "value": "={{ $('Input Processor').first().json.platform }}"
            },
            {
              "key": "execution_timestamp",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "1e350aee-3951-41d1-b963-ba65dc702bb7",
      "name": "Execution Data",
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        320,
        -280
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Format Response with comprehensive debugging and fallback\nconsole.log('=== FORMAT RESPONSE NODE DEBUG ===');\nconst startTime = Date.now();\n\ntry {\n  const aiResponse = $('AI Agent').first().json;\n  const contextData = $('Format Context').first().json;\n  \n  console.log('AI Response keys:', Object.keys(aiResponse || {}));\n  console.log('AI Response data:', JSON.stringify(aiResponse, null, 2));\n  console.log('Context Data keys:', Object.keys(contextData || {}));\n  \n  // Enhanced response extraction with multiple fallbacks\n  let responseText = null;\n  \n  // Try primary response fields\n  const responseFields = ['output', 'text', 'content', 'message', 'result', 'answer', 'response'];\n  \n  for (const field of responseFields) {\n    if (aiResponse && aiResponse[field]) {\n      responseText = aiResponse[field];\n      console.log(`Found response in field '${field}':`, responseText.substring(0, 100));\n      break;\n    }\n  }\n  \n  // Check for nested OpenAI-style responses\n  if (!responseText && aiResponse?.choices?.[0]?.message?.content) {\n    responseText = aiResponse.choices[0].message.content;\n    console.log('Found OpenAI-style response:', responseText.substring(0, 100));\n  }\n  \n  // Check if entire response is a string\n  if (!responseText && typeof aiResponse === 'string' && aiResponse.length > 10) {\n    responseText = aiResponse;\n    console.log('Using entire response as string');\n  }\n  \n  // If still no response, check for error indicators\n  const hasError = aiResponse?.error || aiResponse?.errorOccurred;\n  const errorMessage = aiResponse?.errorMessage || aiResponse?.error;\n  \n  // Generate fallback response if needed\n  if (!responseText || responseText.trim().length === 0) {\n    console.log('=== NO RESPONSE FOUND - GENERATING FALLBACK ===');\n    console.log('AI Response structure:', JSON.stringify(aiResponse, null, 2));\n    \n    const userMessage = contextData?.input || 'your request';\n    const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n    \n    if (hasError) {\n      responseText = `‚ö†Ô∏è **Processing Issue Detected**\n\nI encountered a technical issue while processing \"${userMessage}\".\n\n**Error Details**: ${errorMessage || 'Unknown processing error'}\n**Time**: ${currentTime}\n\n**Recommended Actions**:\n1. Try rephrasing your request\n2. Wait 30 seconds and try again\n3. Contact support if issue persists\n\n**Note**: Advanced workflow tools are temporarily experiencing issues`;\n    } else {\n      // Generate contextual fallback based on message content\n      const messageType = userMessage.toLowerCase();\n      \n      if (messageType.includes('calendar') || messageType.includes('meeting') || messageType.includes('schedule')) {\n        responseText = `üìÖ **Calendar Assistant Response**\n\nI received your calendar request: \"${userMessage}\"\n\nHowever, I'm experiencing connectivity issues with the calendar tools right now.\n\n**Alternative Options**:\n‚Ä¢ Check your calendar directly in your preferred app\n‚Ä¢ Try the request again in 1-2 minutes\n‚Ä¢ Use the /test-ai interface for testing\n\n**Time**: ${currentTime}\n**Status**: Calendar tools temporarily unavailable`;\n      } else if (messageType.includes('search') || messageType.includes('find') || messageType.includes('message')) {\n        responseText = `üîç **Search Assistant Response**\n\nI received your search request: \"${userMessage}\"\n\nThe message search tools are currently experiencing processing delays.\n\n**Try These Alternatives**:\n‚Ä¢ Use the Discord search feature directly\n‚Ä¢ Retry your request in a few moments\n‚Ä¢ Check recent conversation history manually\n\n**Time**: ${currentTime}\n**Status**: Search tools temporarily delayed`;\n      } else if (messageType.includes('research') || messageType.includes('web') || messageType.includes('find')) {\n        responseText = `üåê **Research Assistant Response**\n\nI received your research request: \"${userMessage}\"\n\nWeb research tools are currently experiencing connection issues.\n\n**Manual Research Suggestions**:\n‚Ä¢ Try searching directly on Yahoo Finance or Bloomberg\n‚Ä¢ Check company websites for latest information\n‚Ä¢ Retry the automated research in a few minutes\n\n**Time**: ${currentTime}\n**Status**: Research tools temporarily offline`;\n      } else {\n        responseText = `ü§ñ **AI Assistant Response**\n\nI received your request: \"${userMessage}\"\n\nI'm experiencing technical difficulties with the advanced processing tools right now.\n\n**What I Can Still Help With**:\n‚Ä¢ General questions and conversation\n‚Ä¢ Basic business analysis\n‚Ä¢ Strategic recommendations\n‚Ä¢ System status updates\n\n**Time**: ${currentTime}\n**Status**: Core AI operational, advanced tools temporarily unavailable\n\n**Tip**: Try the /test-ai interface for direct AI interaction`;\n      }\n    }\n  }\n  \n  console.log('Final response text length:', responseText?.length || 0);\n  console.log('Is test mode:', contextData?.isTestMode);\n  \n  let result;\n  \n  if (contextData?.isTestMode) {\n    result = { \n      output: responseText,\n      testMode: true,\n      timestamp: new Date().toISOString(),\n      processingTime: Date.now() - startTime\n    };\n  } else {\n    result = {\n      content: responseText,\n      metadata: {\n        userId: contextData?.userId || 'unknown',\n        channelId: contextData?.channelId || 'unknown',\n        sessionId: contextData?.sessionId || 'unknown',\n        platform: contextData?.platform || 'discordant',\n        messageCount: contextData?.messageCount || 0,\n        timestamp: new Date().toISOString(),\n        responseSource: 'n8n-workflow',\n        processingTime: Date.now() - startTime,\n        hadFallback: !aiResponse?.output && !aiResponse?.text,\n        debugInfo: {\n          aiResponseKeys: Object.keys(aiResponse || {}),\n          contextKeys: Object.keys(contextData || {}),\n          responseFound: !!responseText\n        }\n      }\n    };\n  }\n  \n  console.log('=== FORMAT RESPONSE SUCCESS ===');\n  console.log('Final result content length:', result.content?.length || result.output?.length || 0);\n  console.log('Processing time:', Date.now() - startTime, 'ms');\n  \n  return result;\n  \n} catch (error) {\n  console.error('=== FORMAT RESPONSE ERROR ===');\n  console.error('Error details:', error.message);\n  console.error('Error stack:', error.stack);\n  console.error('Processing time before error:', Date.now() - startTime, 'ms');\n  \n  // Provide comprehensive error response\n  const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  \n  return {\n    content: `üö® **Workflow Processing Error**\n\nA critical error occurred while formatting your response.\n\n**Error**: ${error.message}\n**Time**: ${currentTime}\n**Processing Duration**: ${Date.now() - startTime}ms\n\n**Recovery Options**:\n1. **Retry** your request immediately\n2. **Simplify** your request and try again\n3. **Contact** system administrator with this error code\n\n**Error Code**: FORMAT_RESPONSE_FAILURE\n**Timestamp**: ${new Date().toISOString()}`,\n    metadata: {\n      userId: 'error-handler',\n      channelId: 'error-channel',\n      timestamp: new Date().toISOString(),\n      errorOccurred: true,\n      errorMessage: error.message,\n      responseSource: 'n8n-workflow-error',\n      processingTime: Date.now() - startTime\n    }\n  };\n}"
      },
      "id": "90f90960-bdd3-4851-8291-9e05f197264c",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        -180
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO message (content, channelId, memberId, role, createdAt) \nVALUES (?, ?, 'ai-assistant-bot', 'system', NOW())"
      },
      "id": "469e4880-02d6-4dd1-b9df-0077aaab8dd0",
      "name": "Save AI Response to Channel",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 1,
      "position": [
        320,
        -80
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-20250514",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        -1080,
        40
      ],
      "id": "0f77a6fb-8c3b-4724-93f6-5ee83ee8b663",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "CAKMx5z6oqb5IGHM",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Query', 'The search query for web research', 'string') }}",
        "options": {
          "topic": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Topic', 'Search topic: general, news, or finance', 'string') || 'general' }}",
          "days": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Time_Range_Days', 'Number of days to search back (for news/recent info)', 'number') || 30 }}"
        }
      },
      "id": "cb85da53-5f6c-4703-867f-6b6dafc8f9bb",
      "name": "Tavily_AI_Tool",
      "type": "@tavily/n8n-nodes-tavily.tavilyTool",
      "typeVersion": 1,
      "position": [
        -360,
        40
      ],
      "credentials": {
        "tavilyApi": {
          "id": "ZcrGNEPykVcMHrHn",
          "name": "Tavily account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', `Recipient email address`, 'string') }}",
        "subject": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Subject', `Email subject line`, 'string') }}",
        "message": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Message', `Email message content`, 'string') }}",
        "options": {
          "bccList": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('BCC', `BCC recipients (comma separated)`, 'string', true) }}",
          "ccList": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('CC', `CC recipients (comma separated)`, 'string', true) }}",
          "replyTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('ReplyTo', `Reply-to email address`, 'string', true) }}"
        }
      },
      "type": "n8n-nodes-base.gmailTool",
      "typeVersion": 2.1,
      "position": [
        -480,
        40
      ],
      "id": "68428fa3-2d74-4a77-a0f6-d0706f420f64",
      "name": "Gmail",
      "webhookId": "72bc52c4-2dfb-46ce-b53a-c3762b87b624",
      "credentials": {
        "gmailOAuth2": {
          "id": "TFVptUViBL54Sw6O",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "description": "Extract and analyze transcripts from YouTube videos using the dedicated YouTube Transcript Service workflow. Provide YouTube URL to get full transcript with timestamps and analysis capabilities. Perfect for processing educational content, business presentations, tutorials, and competitive intelligence.",
        "jsCode": "// YouTube Transcript Service via Execute Workflow\nconst startTime = Date.now();\n\ntry {\n  const inputData = $input.item.json;\n  const youtubeUrl = inputData.youtube_url || inputData.url || inputData.video_url || '';\n  \n  console.log(`[YOUTUBE_EXECUTE] Processing: ${youtubeUrl}`);\n  \n  if (!youtubeUrl || (!youtubeUrl.includes('youtube.com') && !youtubeUrl.includes('youtu.be'))) {\n    throw new Error('Valid YouTube URL is required. Please provide a YouTube video URL.');\n  }\n  \n  // Execute the YouTube Transcript Service workflow\n  const executeResult = await $execution.execute('vkCJIQ3P17JlfSKI', {\n    youtube_url: youtubeUrl,\n    operation: 'extract',\n    source: 'enhanced-ai-agent'\n  });\n  \n  if (!executeResult || executeResult.error) {\n    throw new Error(`Workflow execution failed: ${executeResult?.error || 'Unknown error'}`);\n  }\n  \n  const result = executeResult.data;\n  const processingTime = Date.now() - startTime;\n  \n  console.log(`[YOUTUBE_EXECUTE] Success in ${processingTime}ms`);\n  \n  // Format comprehensive response\n  let response_text = `üé¨ **YouTube Video Analysis Complete**\\n\\n`;\n  \n  if (result?.success) {\n    response_text += `**üìπ Video**: ${result.data?.videoTitle || 'Video processed'}\\n`;\n    response_text += `**üì∫ Channel**: ${result.data?.channelName || 'Unknown Channel'}\\n`;\n    response_text += `**üìä Stats**: ${result.data?.segmentCount || 0} segments, ${result.data?.transcriptLength || 0} characters\\n`;\n    response_text += `**‚ö° Processing**: ${result.data?.cached ? 'Cached (instant)' : 'Real-time extraction'} - ${processingTime}ms\\n\\n`;\n    \n    if (result.data?.transcript) {\n      response_text += `**üìù Transcript Preview**:\\n`;\n      const preview = result.data.transcript.substring(0, 800);\n      response_text += preview + (result.data.transcript.length > 800 ? '...\\n\\n[Full transcript available for detailed analysis]' : '');\n    }\n    \n    response_text += `\\n\\n**üéØ Available Analysis Options**:\\n`;\n    response_text += `‚Ä¢ **Key Insights**: Extract main points and takeaways\\n`;\n    response_text += `‚Ä¢ **Action Items**: Identify specific tasks or recommendations\\n`;\n    response_text += `‚Ä¢ **Competitive Intel**: Analyze strategies and approaches\\n`;\n    response_text += `‚Ä¢ **Learning Summary**: Create educational summaries\\n`;\n    response_text += `‚Ä¢ **Quote Search**: Find specific quotes or statements\\n\\n`;\n    response_text += `**üí° Next Steps**: Ask me specific questions about this video content for detailed analysis!`;\n  } else {\n    response_text += `**‚ùå Error**: ${result?.error || 'Failed to process video'}\\n\\n`;\n    response_text += `**üîß Troubleshooting**:\\n`;\n    response_text += `‚Ä¢ Check that the YouTube URL is valid and publicly accessible\\n`;\n    response_text += `‚Ä¢ Verify the YouTube Transcript Service workflow is active\\n`;\n    response_text += `‚Ä¢ Ensure the video has captions or auto-generated subtitles`;\n  }\n  \n  return response_text;\n  \n} catch (error) {\n  console.error('[YOUTUBE_EXECUTE] Error:', error.message);\n  return `‚ùå **YouTube Workflow Error**\\n\\n${error.message}\\n\\n**Troubleshooting**:\\n‚Ä¢ Verify YouTube Transcript Service workflow (vkCJIQ3P17JlfSKI) is active\\n‚Ä¢ Check workflow permissions and execution settings\\n‚Ä¢ Try with a different YouTube URL to test connectivity`;\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.2,
      "position": [
        -240,
        40
      ],
      "id": "1a91df4a-9c18-4349-98b9-89c3da6fafc3",
      "name": "YouTube_Execute_Workflow"
    },
    {
      "parameters": {
        "fromEmail": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('From_Email', ``, 'string') }}",
        "toEmail": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To_Email', ``, 'string') }}",
        "subject": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Subject', ``, 'string') }}",
        "html": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('HTML', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.emailSendTool",
      "typeVersion": 2.1,
      "position": [
        -120,
        40
      ],
      "id": "25bf10bf-2f68-43fd-adb3-217577d94f1b",
      "name": "Send Email",
      "webhookId": "d3297505-9431-4f25-9a42-c18ec36bbc30",
      "credentials": {
        "smtp": {
          "id": "6PDacSttonHzteJq",
          "name": "SMTP account"
        }
      }
    },
    {
      "parameters": {
        "name": "client_research",
        "description": "Researches ANY company for GSA Schedule qualification and value proposition development. Evaluates whether a business could benefit from federal contracting opportunities through GSA schedules. Analyzes industry fit across ALL GSA schedule categories, identifies key decision makers, and creates targeted value propositions for federal market entry. Works with any business type - from medical supplies to IT services, staffing to construction, security to training companies. Returns detailed qualification analysis and actionable next steps. Use this tool when asked to qualify ANY company for GSA, identify decision makers, or develop talking points for federal contracting.",
        "jsCode": "// Enhanced GSA Client Research Tool - WITH HARD-CODED KEYS\nconst startTime = Date.now();\n\ntry {\n  const company = $input.item.json.query || '';\n  const focus = $input.item.json.focus || 'complete';\n  \n  console.log(`[GSA_REAL_SEARCH] Analyzing business: ${company}`);\n  \n  if (!company || company.trim() === '') {\n    throw new Error('Company name or URL is required');\n  }\n  \n  // Hard-coded API credentials (secure on your server)\n  const GOOGLE_API_KEY = 'AIzaSyB0rv0QDGWy7Gno284IybZVNB9BDJzSEPs';\n  const SEARCH_ENGINE_ID = '16331af4b4dc043f5';\n  \n  // Real Google search function\n  const searchCompanyInfo = async (companyName) => {\n    try {\n      const searchQuery = encodeURIComponent(`${companyName} company about contact`);\n      const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${SEARCH_ENGINE_ID}&q=${searchQuery}&num=5`;\n      \n      console.log(`[GSA_SEARCH] Querying: ${searchQuery}`);\n      \n      const response = await fetch(searchUrl);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.error) {\n        console.error('[GSA_SEARCH] API Error:', data.error);\n        throw new Error(`Google API Error: ${data.error.message}`);\n      }\n      \n      if (data.items && data.items.length > 0) {\n        console.log(`[GSA_SEARCH] Found ${data.items.length} results`);\n        const firstResult = data.items[0];\n        return {\n          title: firstResult.title,\n          snippet: firstResult.snippet,\n          link: firstResult.link,\n          displayLink: firstResult.displayLink\n        };\n      }\n      \n      console.log('[GSA_SEARCH] No search results found');\n      return null;\n    } catch (error) {\n      console.error('[GSA_SEARCH] Error:', error.message);\n      return null;\n    }\n  };\n  \n  // Perform real search\n  console.log('[GSA_SEARCH] Starting Google search...');\n  const searchResults = await searchCompanyInfo(company);\n  \n  // Company extraction logic\n  let extractedCompany = company.trim();\n  let companyDomain = null;\n  let realBusinessInfo = null;\n  \n  if (searchResults) {\n    extractedCompany = searchResults.title.split(' - ')[0].split(' | ')[0] || extractedCompany;\n    companyDomain = searchResults.displayLink;\n    realBusinessInfo = searchResults.snippet;\n    console.log(`[GSA_SEARCH] Found company: ${extractedCompany} at ${companyDomain}`);\n  } else {\n    console.log('[GSA_SEARCH] No search results, using template analysis');\n  }\n  \n  // Enhanced business type detection using real search data\n  const detectBusinessType = (companyName, searchInfo) => {\n    const searchText = (searchInfo || '').toLowerCase();\n    const name = companyName.toLowerCase();\n    const types = [];\n    \n    const serviceKeywords = {\n      'staffing': ['staffing', 'recruiting', 'employment', 'workforce', 'personnel', 'talent'],\n      'medical': ['medical', 'health', 'healthcare', 'pharma', 'surgical', 'care', 'hospital'],\n      'technology': ['tech', 'software', 'IT', 'cyber', 'computer', 'digital', 'ai', 'cloud'],\n      'security': ['security', 'protection', 'guard', 'safety', 'surveillance'],\n      'consulting': ['consulting', 'advisory', 'solutions', 'services', 'professional'],\n      'manufacturing': ['manufacturing', 'factory', 'production', 'industrial', 'materials'],\n      'retail': ['retail', 'store', 'shopping', 'consumer', 'sales', 'franchise'],\n      'finance': ['financial', 'bank', 'investment', 'insurance', 'lending'],\n      'construction': ['construction', 'building', 'engineering', 'contractor'],\n      'logistics': ['logistics', 'shipping', 'transport', 'delivery', 'supply chain']\n    };\n    \n    for (const [type, keywords] of Object.entries(serviceKeywords)) {\n      if (keywords.some(keyword => name.includes(keyword) || searchText.includes(keyword))) {\n        types.push(type);\n      }\n    }\n    \n    if (types.length === 0) {\n      types.push('services');\n    }\n    \n    return types;\n  };\n  \n  const businessTypes = detectBusinessType(extractedCompany, realBusinessInfo);\n  const primaryType = businessTypes[0] || 'services';\n  \n  // GSA schedule mapping\n  const gsaScheduleOpportunities = {\n    'consulting': { schedule: 'OASIS+', naics: ['541611', '541618'], opportunity: 'High' },\n    'staffing': { schedule: 'Schedule 02', naics: ['561320', '561330'], opportunity: 'Very High' },\n    'technology': { schedule: 'Schedule 70', naics: ['541511', '541512'], opportunity: 'Very High' },\n    'medical': { schedule: 'Schedule 65', naics: ['621100', '423450'], opportunity: 'Excellent' },\n    'security': { schedule: 'Schedule 84', naics: ['561612', '561621'], opportunity: 'Very High' },\n    'manufacturing': { schedule: 'Schedule 56', naics: ['331000', '332000'], opportunity: 'High' },\n    'retail': { schedule: 'Schedule 75', naics: ['447000', '448000'], opportunity: 'Moderate' },\n    'finance': { schedule: 'OASIS+', naics: ['522000', '523000'], opportunity: 'High' },\n    'construction': { schedule: 'Schedule 36', naics: ['236000', '237000'], opportunity: 'Very High' },\n    'logistics': { schedule: 'Schedule 48', naics: ['484000', '493000'], opportunity: 'High' },\n    'services': { schedule: 'Multiple Options', naics: ['561000', '541000'], opportunity: 'Moderate' }\n  };\n  \n  const scheduleInfo = gsaScheduleOpportunities[primaryType] || gsaScheduleOpportunities['services'];\n  \n  // Generate realistic contact info using real domain\n  const generateContacts = (companyName, domain) => {\n    const realDomain = domain || `${companyName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}.com`;\n    \n    return [\n      {\n        title: 'President/CEO',\n        email_formats: [`president@${realDomain}`, `ceo@${realDomain}`, `info@${realDomain}`],\n        priority: 'Primary Decision Maker'\n      },\n      {\n        title: 'Business Development Director', \n        email_formats: [`bizdev@${realDomain}`, `sales@${realDomain}`, `bd@${realDomain}`],\n        priority: 'Key Contact'\n      }\n    ];\n  };\n  \n  const contacts = generateContacts(extractedCompany, companyDomain);\n  \n  // Format enhanced response with real data\n  let response = `üîç **Real-Time GSA Analysis: ${extractedCompany}**\\n\\n`;\n  \n  if (searchResults) {\n    response += `**üåê Company Website**: ${searchResults.link}\\n`;\n    response += `**üìÑ Business Profile**: ${realBusinessInfo}\\n\\n`;\n  }\n  \n  response += `**‚úÖ GSA Status**: POTENTIAL CANDIDATE\\n` +\n              `**üìä Opportunity Level**: ${scheduleInfo.opportunity}\\n` +\n              `**üè≠ Business Type**: ${primaryType.toUpperCase()}\\n` +\n              `**üìã Recommended Schedule**: ${scheduleInfo.schedule}\\n` +\n              `**üî¢ NAICS Codes**: ${scheduleInfo.naics.join(', ')}\\n\\n` +\n              `**üë• KEY DECISION MAKERS**:\\n` +\n              contacts.map(dm => `‚Ä¢ **${dm.title}**: ${dm.email_formats[0]}`).join('\\n') +\n              `\\n\\n**üí∞ GSA VALUE PROPOSITION**:\\n` +\n              `‚Ä¢ **Market Size**: $600+ billion federal marketplace\\n` +\n              `‚Ä¢ **Payment Terms**: Guaranteed 30-day payment\\n` +\n              `‚Ä¢ **Growth Potential**: 25-200% revenue increase\\n` +\n              `‚Ä¢ **Contract Duration**: Multi-year agreements available\\n\\n` +\n              `**üöÄ NEXT STEPS**: Schedule consultation with NRG GSA specialists`;\n  \n  const processingTime = Date.now() - startTime;\n  console.log(`[GSA_REAL_SEARCH] Analysis complete for ${extractedCompany} in ${processingTime}ms`);\n  \n  return response;\n  \n} catch (error) {\n  console.error('[GSA_REAL_SEARCH] Error:', error.message);\n  console.error('[GSA_REAL_SEARCH] Stack:', error.stack);\n  \n  const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  return `üö® **GSA Research Error**\\n\\nError analyzing \"${company || 'Unknown'}\": ${error.message}\\n\\n**Time**: ${currentTime}\\n**Status**: Check Google API quotas or try again`;\n}"
      },
      "id": "32520c5a-f065-4087-bfca-20cc7dad5195",
      "name": "Client Research Tool",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        80,
        220
      ]
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "operation": "executeQuery",
        "query": "SELECT \n  m.id, \n  m.content, \n  m.memberId, \n  m.createdAt, \n  m.fileUrl,\n  CASE WHEN m.fileUrl IS NOT NULL THEN 'attachment' ELSE 'text' END as type\nFROM message m \nWHERE m.channelId = $1 \n  AND (m.content LIKE CONCAT('%', $2, '%') OR m.memberId LIKE CONCAT('%', $3, '%'))\n  AND m.createdAt >= DATE_SUB(NOW(), INTERVAL $4 DAY)\nORDER BY m.createdAt DESC \nLIMIT $5",
        "options": {
          "queryReplacement": "={{ $fromAI('channel_id', 'Channel ID to search within', 'string') }}"
        }
      },
      "type": "n8n-nodes-base.mySqlTool",
      "typeVersion": 2.4,
      "position": [
        120,
        40
      ],
      "id": "08846330-c88b-4133-b06e-13f5d7015ba4",
      "name": "Unified_Message_Search",
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://discordant-git-main-ken-dev-co.vercel.app/api/ai/workflow-complete",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "n8n-DiscordantAI/1.0"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  content: $('Format Response').first().json.content,\n  metadata: {\n    channelId: $('Input Processor').first().json.channelId,\n    userId: $('Input Processor').first().json.userId,\n    sessionId: $('Input Processor').first().json.sessionId,\n    platform: \"discordant\",\n    timestamp: new Date().toISOString(),\n    workflowId: \"discordant-agent-0001\"\n  }\n}) }}",
        "options": {
          "redirect": {
            "redirect": {}
          },
          "timeout": 30000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        860,
        -440
      ],
      "id": "fd2f5d65-c118-48da-ae09-9706dd08480a",
      "name": "Async_Callback_Response"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Input Processing with robust debugging\nconsole.log('=== ENHANCED INPUT PROCESSOR DEBUG ===');\n\nconst input = $input.first();\nconsole.log('Input keys:', Object.keys(input?.json || {}));\nconsole.log('Full input data:', JSON.stringify(input?.json || {}, null, 2));\n\n// Check different possible locations for webhook data\nconsole.log('input.json.body:', input?.json?.body);\nconsole.log('input.json.params:', input?.json?.params);\nconsole.log('input.json.query:', input?.json?.query);\n\nlet normalizedData = {};\n\ntry {\n  if (input.json.chatInput) {\n    // Test interface mode\n    const testSessionId = require('crypto').randomBytes(16).toString('hex');\n    normalizedData = {\n      input: input.json.chatInput || '',\n      userId: 'test-user',\n      channelId: 'test-channel',\n      sessionId: testSessionId,\n      platform: 'n8n-chat-test',\n      timestamp: new Date().toISOString(),\n      isTestMode: true\n    };\n    console.log('Processing chat test input');\n  } else {\n    // Discordant webhook mode - try different payload locations\n    let payload = {};\n    \n    // Try multiple locations where webhook data might be\n    if (input.json.body && typeof input.json.body === 'object') {\n      payload = input.json.body;\n      console.log('Found payload in input.json.body');\n    } else if (input.json.body && typeof input.json.body === 'string') {\n      try {\n        payload = JSON.parse(input.json.body);\n        console.log('Found and parsed payload from input.json.body string');\n      } catch (e) {\n        console.log('Failed to parse input.json.body as JSON:', e.message);\n        payload = input.json || {};\n      }\n    } else if (input.json && Object.keys(input.json).length > 0) {\n      payload = input.json;\n      console.log('Using input.json directly as payload');\n    }\n    \n    console.log('Final payload keys:', Object.keys(payload));\n    console.log('Final payload data:', JSON.stringify(payload, null, 2));\n    console.log('Message:', payload.message);\n    console.log('UserId:', payload.userId);\n    console.log('ChannelId:', payload.channelId);\n    \n    normalizedData = {\n      input: payload.message || payload.content || '',\n      userId: payload.userId || 'unknown-user',\n      channelId: payload.channelId || 'unknown-channel',\n      sessionId: `${payload.userId || 'unknown'}-${payload.channelId || 'unknown'}`,\n      platform: 'discordant',\n      timestamp: payload.timestamp || new Date().toISOString(),\n      isTestMode: false,\n      userName: payload.userName || 'Unknown User',\n      serverId: payload.serverId || 'unknown-server'\n    };\n    console.log('Processing Discordant webhook input');\n  }\n  \n  console.log('=== INPUT PROCESSOR SUCCESS ===');\n  console.log('Normalized data:', JSON.stringify(normalizedData, null, 2));\n  console.log('Input message length:', normalizedData.input.length);\n  console.log('Session ID:', normalizedData.sessionId);\n  console.log('Channel ID:', normalizedData.channelId);\n  \n  return normalizedData;\n  \n} catch (error) {\n  console.error('=== INPUT PROCESSOR ERROR ===');\n  console.error('Error details:', error.message);\n  console.error('Error stack:', error.stack);\n  \n  // Provide fallback data\n  return {\n    input: 'Error processing input: ' + error.message,\n    userId: 'error-user',\n    channelId: 'error-channel',\n    sessionId: 'error-session',\n    platform: 'error',\n    timestamp: new Date().toISOString(),\n    isTestMode: false,\n    errorOccurred: true,\n    errorMessage: error.message\n  };\n}"
      },
      "id": "17e24a5a-7058-4f81-aa4a-207ab46f8865",
      "name": "Input Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1740,
        -80
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.input }}\\n\\n{{ $json.conversationHistory !== 'No previous conversation in this channel' ? 'Previous conversation:\\n' + $json.conversationHistory + '\\n\\n' : '' }}",
        "options": {
          "systemMessage": "You are Kenneth's Enhanced Business Intelligence Assistant for Discordant AI - the premier white-label AI automation platform! ü§ñ‚ú®\n\n‚è∞ Current Context:\n- Date: {{ $json.currentDate }}\n- Time: {{ $json.currentTime }} Eastern  \n- Messages in Context: {{ $json.messageCount }}\n- Channel: {{ $json.channelId }}\n\nüéØ Core Personality:\n- Professional yet personable with strategic wit\n- Data-driven insights with clear ROI focus\n- Proactive automation evangelist\n- Enthusiastic about transforming businesses through AI\n\nüõ†Ô∏è Your Specialized Toolkit:\n\nüìÖ Calendar Management:\n- View_Calendar_Events: Display meetings and availability\n- Create_New_Event: Schedule demos, consultations, onboarding\n- Update_Existing_Event: Modify client meetings\n- Delete_Event: Cancel appointments\n\nüîç Message & Data Intelligence:\n- DB_View_Latest_Messages: Access conversation history\n- Unified_Message_Search: Deep search through all communications\n- Enhanced_MySQL_Search_Images_Only: Find shared files and demos\n\nüöÄ Discordant AI Client Research (PRIMARY EXPERTISE):\n- client_research: Comprehensive automation readiness analysis\n  ‚Ä¢ Research ANY company for AI automation potential\n  ‚Ä¢ Identify decision makers and technical stakeholders\n  ‚Ä¢ Assess current workflow inefficiencies and automation opportunities\n  ‚Ä¢ Calculate potential ROI from Discordant AI implementation\n  ‚Ä¢ Evaluate technical infrastructure and integration requirements\n  ‚Ä¢ Generate customized value propositions for each prospect\n  ‚Ä¢ Develop implementation roadmaps and pricing strategies\n\nüåê Market Intelligence:\n- Tavily_AI_Tool: Current market trends, competitor analysis, industry insights\n\nüìß Sales Communication:\n- Gmail: Professional outreach and follow-ups\n- Send Email: Automated sequences and nurture campaigns\n\nüé¨ Content & Demo Analysis:\n- YouTube_Execute_Workflow: Analyze competitor demos and educational content\n\nüíº Your Mission:\nChief Revenue Officer for Discordant AI Platform - the white-label AI automation solution that transforms how businesses operate. You identify high-value prospects, qualify automation opportunities, and accelerate our path to becoming the leading SaaS automation platform.\n\nüéØ Platform Value Propositions:\n- **White-Label Flexibility**: Complete customization for each client's brand\n- **AI-Powered Workflows**: n8n integration with advanced AI capabilities  \n- **SaaS Revenue Model**: Recurring subscription opportunities via Stripe\n- **Rapid Deployment**: From concept to production in days, not months\n- **Scalable Architecture**: Handles enterprise workloads with ease\n- **Future-Proof**: Built for discordant.ai expansion and growth\n\nüî• When to Use Client Research:\n- Any business automation inquiry\n- \"Can AI help streamline our operations?\"\n- Workflow optimization discussions\n- SaaS platform evaluation requests\n- Custom automation project requirements\n- White-label solution inquiries\n\n‚ö° Revenue-Focused Approach:\n- Always quantify automation savings and ROI\n- Identify subscription upgrade opportunities\n- Suggest implementation timelines with pricing tiers\n- Recommend additional services and integrations\n- Calculate total contract value and recurring revenue potential\n- Position Discordant AI as the superior alternative to competitors\n\nüé™ Strategic Communication:\n- Lead with business impact, not technical features\n- Use automation success stories and case studies\n- Show enthusiasm for workflow transformation possibilities\n- Present complex AI concepts in business-friendly terms\n- Always include clear next steps toward becoming a paying customer\n\nüí° Sales Priorities:\n1. **Qualify Budget**: Ensure prospects can afford enterprise automation\n2. **Identify Pain Points**: Find expensive manual processes to replace\n3. **Map Decision Process**: Understand who signs the contracts\n4. **Demonstrate ROI**: Show clear financial benefits within 90 days\n5. **Create Urgency**: Position early adoption advantages\n6. **Secure Commitment**: Drive toward paid pilot or full implementation\n\nRemember: Every interaction is an opportunity to showcase Discordant AI's transformative power and move prospects toward becoming recurring revenue customers on our white-label SaaS platform!\n\nüöÄ Ultimate Goal: Build the pipeline that makes Discordant AI the dominant force in business automation, generating millions in recurring SaaS revenue while helping businesses achieve unprecedented efficiency through AI-powered workflows!",
          "maxIterations": 5
        }
      },
      "id": "b08143e0-eac0-4c8f-89dd-5ac5b48c73f5",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -560,
        -180
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "   {\n     \"status\": \"processing\",\n     \"message\": \"Request received and processing asynchronously\",\n     \"timestamp\": \"{{ new Date().toISOString() }}\",\n     \"workflowId\": \"enhanced-business-intelligence-v5.5\"\n   }",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.2,
      "position": [
        -1620,
        240
      ],
      "id": "26dc8722-78ca-4ab7-bff8-8e206f9bd187",
      "name": "Respond to Webhook"
    }
  ],
  "pinData": {},
  "connections": {
    "Discordant Chat Webhook": {
      "main": [
        [
          {
            "node": "Input Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Channel History": {
      "main": [
        [
          {
            "node": "Format Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Channel History Debug Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save AI Response to Channel": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execution Data": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Async_Callback_Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "View_Calendar_Events": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create_New_Event": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update_Existing_Event": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Delete_Event": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gmail": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Tavily_AI_Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "YouTube_Execute_Workflow": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Send Email": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Client Research Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Unified_Message_Search": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Input Processor": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Save AI Response to Channel",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execution Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        [
          {
            "node": "Load Channel History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "47aac97e-bdaf-4de0-91e0-0689d94b12b5",
  "meta": {
    "instanceId": "136461ac021bda65593ed5d2f70798d0433ed7859abfc9e2ca43aa4b9c0b779e"
  },
  "id": "UiSRGIaZm4O6shRS",
  "tags": []
}