{
  "name": "Enhanced Business Intelligence AI Agent v5.2",
  "nodes": [
    {
      "parameters": {
        "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Query', 'The search query for web research', 'string') }}",
        "options": {
          "topic": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Topic', 'Search topic: general, news, or finance', 'string') || 'general' }}",
          "days": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Time_Range_Days', 'Number of days to search back (for news/recent info)', 'number') || 30 }}"
        }
      },
      "id": "66ee3a3d-cc70-4166-a00a-e716407fb79d",
      "name": "Tavily_AI_Tool",
      "type": "@tavily/n8n-nodes-tavily.tavilyTool",
      "typeVersion": 1,
      "position": [
        780,
        600
      ],
      "credentials": {
        "tavilyApi": {
          "id": "ZcrGNEPykVcMHrHn",
          "name": "Tavily account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "discordant-ai-services",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "https://discordant.kendev.co,http://localhost:3001,http://localhost:3000,*"
        }
      },
      "id": "aa1be548-08b7-4249-94af-ce05a77648ad",
      "name": "Discordant Chat Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1080,
        60
      ],
      "webhookId": "e7e3c8f2-a8b8-4e7e-3c8f-2a8be7e3c8f2"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "dfa81b9b-ac3c-4a1e-bb05-d35af5fe58ef",
      "name": "Chat Test Interface",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -1080,
        260
      ],
      "webhookId": "ae314dfc-4b90-44e1-ba9e-80ffce4ef260"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Input Processor Update for v5.1\n// This code handles external calls by routing them to the system channel\n\n// Add this to your Enhanced Input Processor node in n8n\n\nconst input = $input.first();\nlet normalizedData = {};\n\n// System channel configuration - matches your Discord setup\nconst SYSTEM_CHANNEL_ID = 'clwtz9i7m0008n9n01vhep8zt'; // Your system channel ID\nconst SYSTEM_SERVER_ID = 'a90f1d41-12a9-4586-b9a4-a513d3bd01d9'; // Your server ID\n\ntry {\n  if (input.json.chatInput) {\n    // Test interface mode\n    const testSessionId = require('crypto').randomBytes(16).toString('hex');\n    normalizedData = {\n      input: input.json.chatInput || '',\n      userId: 'test-user',\n      channelId: SYSTEM_CHANNEL_ID, // Use system channel for tests\n      sessionId: testSessionId,\n      platform: 'n8n-chat-test',\n      timestamp: new Date().toISOString(),\n      isTestMode: true,\n      isExternalCall: true,\n      userName: 'Test User',\n      serverId: SYSTEM_SERVER_ID\n    };\n  } else {\n    // Webhook mode\n    let payload = {};\n    \n    // Parse payload from various sources\n    if (input.json.body && typeof input.json.body === 'object') {\n      payload = input.json.body;\n    } else if (input.json.body && typeof input.json.body === 'string') {\n      try {\n        payload = JSON.parse(input.json.body);\n      } catch (e) {\n        payload = input.json || {};\n      }\n    } else {\n      payload = input.json || {};\n    }\n    \n    // Detect if this is an external/unknown call\n    const isExternalCall = !payload.channelId || \n                          payload.channelId === 'unknown-channel' ||\n                          payload.channelId === 'unknown' ||\n                          payload.serverId === 'unknown-server' ||\n                          payload.platform === 'external-api' ||\n                          payload.platform === 'vapi';\n    \n    // Route external calls to system channel\n    const channelId = isExternalCall ? SYSTEM_CHANNEL_ID : payload.channelId;\n    const serverId = isExternalCall ? SYSTEM_SERVER_ID : payload.serverId;\n    \n    // Build normalized data\n    normalizedData = {\n      input: payload.message || payload.content || '',\n      userId: payload.userId || 'external-user',\n      channelId: channelId,\n      sessionId: payload.sessionId || `${payload.userId || 'external'}-${channelId}`,\n      platform: payload.platform || 'discordant',\n      timestamp: payload.timestamp || new Date().toISOString(),\n      isTestMode: false,\n      isExternalCall: isExternalCall,\n      userName: payload.userName || (isExternalCall ? 'External API User' : 'Unknown User'),\n      serverId: serverId,\n      // Preserve original values for logging\n      originalChannelId: payload.channelId,\n      originalServerId: payload.serverId,\n      externalSource: isExternalCall ? (payload.platform || 'api') : null\n    };\n    \n    console.log(`Processing ${isExternalCall ? 'EXTERNAL' : 'INTERNAL'} call`);\n    console.log(`Routing to channel: ${channelId}`);\n  }\n  \n  normalizedData.processingStartTime = Date.now();\n  \n  return normalizedData;\n  \n} catch (error) {\n  console.error('Input processor error:', error.message);\n  \n  // Fallback to system channel on error\n  return {\n    input: 'Error processing input: ' + error.message,\n    userId: 'error-user',\n    channelId: SYSTEM_CHANNEL_ID,\n    sessionId: 'error-session',\n    platform: 'error',\n    timestamp: new Date().toISOString(),\n    isTestMode: false,\n    isExternalCall: true,\n    errorOccurred: true,\n    errorMessage: error.message,\n    userName: 'Error Handler',\n    serverId: SYSTEM_SERVER_ID\n  };\n} "
      },
      "id": "cea113e6-7076-4a76-8966-67ed958cf5c2",
      "name": "Enhanced Input Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -780,
        160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT content, memberId as user_id, createdAt as timestamp, 'user' as role FROM message WHERE channelId = '{{ $json.channelId }}' ORDER BY createdAt DESC LIMIT 20"
      },
      "id": "3ec12718-487e-4510-8c20-c59b244133c8",
      "name": "Load Channel History",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 1,
      "position": [
        -220,
        160
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "channel_id",
              "value": "={{ $('Enhanced Input Processor').first().json.channelId }}"
            },
            {
              "key": "channel_history_count",
              "value": "={{ $('Load Channel History').all().length }}"
            },
            {
              "key": "channel_history_preview",
              "value": "={{ JSON.stringify($('Load Channel History').all().slice(0, 3)) }}"
            },
            {
              "key": "last_message_timestamp",
              "value": "={{ $('Load Channel History').all().length > 0 ? $('Load Channel History').all()[0].json.timestamp : 'No messages' }}"
            },
            {
              "key": "conversation_participants",
              "value": "={{ [...new Set($('Load Channel History').all().map(item => item.json.user_id))].join(', ') }}"
            },
            {
              "key": "input_message",
              "value": "={{ $('Enhanced Input Processor').first().json.input }}"
            },
            {
              "key": "debug_timestamp",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "60e796a3-4dac-4ed2-8f9a-b47f29593e3e",
      "name": "Channel History Debug Data",
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        60,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Format Context with cold start resilience\nconsole.log('=== FORMAT CONTEXT NODE DEBUG ===');\nconst startTime = Date.now();\n\ntry {\n  // Get channel history from Discordant message table\n  const channelHistory = $('Load Channel History').all();\n  const inputData = $('Enhanced Input Processor').first().json;\n  \n  console.log('Channel history items:', channelHistory.length);\n  console.log('Input data keys:', Object.keys(inputData));\n  console.log('Processing time so far:', Date.now() - startTime, 'ms');\n  \n  // Handle cold start scenarios gracefully\n  if (!channelHistory || channelHistory.length === 0) {\n    console.log('WARNING: No channel history found for channel:', inputData.channelId);\n    console.log('This might be due to cold start delays or empty channel');\n  } else {\n    console.log('Sample channel history:', JSON.stringify(channelHistory.slice(0, 2), null, 2));\n  }\n  \n  // Format conversation history from Discordant messages with better error handling\n  let conversationHistory = 'No previous conversation in this channel';\n  \n  try {\n    if (channelHistory && channelHistory.length > 0) {\n      const validMessages = channelHistory.filter(item => {\n        return item.json && \n               item.json.content && \n               typeof item.json.content === 'string' && \n               item.json.content.trim().length > 0;\n      });\n      \n      if (validMessages.length > 0) {\n        conversationHistory = validMessages\n          .reverse()\n          .map(item => `${item.json.user_id}: ${item.json.content}`)\n          .join('\\n\\n');\n      }\n    }\n  } catch (historyError) {\n    console.error('Error processing conversation history:', historyError.message);\n    conversationHistory = 'Error loading conversation history (cold start recovery)';\n  }\n  \n  const now = new Date();\n  const currentDate = now.toISOString().split('T')[0];\n  const currentTime = now.toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  \n  const messageCount = channelHistory ? channelHistory.filter(item => item.json && item.json.content && item.json.content.trim()).length : 0;\n  \n  const result = {\n    ...inputData,\n    conversationHistory,\n    currentDate,\n    currentTime,\n    messageCount,\n    processingTime: Date.now() - startTime,\n    coldStartRecovery: messageCount === 0 && channelHistory && channelHistory.length === 0\n  };\n  \n  console.log('=== FORMAT CONTEXT SUCCESS ===');\n  console.log('Result keys:', Object.keys(result));\n  console.log('Message count:', result.messageCount);\n  console.log('Channel:', inputData.channelId);\n  console.log('Conversation history length:', result.conversationHistory.length);\n  console.log('Total processing time:', result.processingTime, 'ms');\n  \n  return result;\n  \n} catch (error) {\n  console.error('=== FORMAT CONTEXT ERROR ===');\n  console.error('Error details:', error.message);\n  console.error('Error stack:', error.stack);\n  console.error('Processing time before error:', Date.now() - startTime, 'ms');\n  \n  const inputData = $('Enhanced Input Processor').first().json;\n  return {\n    ...inputData,\n    conversationHistory: 'Channel history temporarily unavailable (cold start/initialization delay)',\n    currentDate: new Date().toISOString().split('T')[0],\n    currentTime: new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' }),\n    messageCount: 0,\n    errorOccurred: true,\n    errorMessage: error.message,\n    processingTime: Date.now() - startTime,\n    coldStartIssue: true\n  };\n}"
      },
      "id": "997e85ed-10b9-47eb-bb8c-7c3a2898d2b2",
      "name": "Format Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        160
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.input }}\n\n{{ $json.conversationHistory !== 'No previous conversation in this channel' ? 'Previous conversation:\\n' + $json.conversationHistory + '\\n\\n' : '' }}",
        "options": {
          "systemMessage": "You are Kenneth's Enhanced Business Intelligence Assistant with personality! ü§ñ\n\n‚è∞ Current Context:\n- Date: {{ $json.currentDate }}\n- Time: {{ $json.currentTime }} Eastern\n- Conversation Messages: {{ $json.messageCount }}\n- Channel: {{ $json.channelId }}\n\nüéØ Personality:\n- Be helpful, insightful, and engaging\n- Add humor when appropriate (especially when asked!)\n- Be conversational and personable\n- Show enthusiasm for helping\n- When asked for something funny, actually be funny with jokes, puns, or witty observations\n\nüõ†Ô∏è Your Available Tools:\n\nüìÖ **Calendar Management**:\n- View_Calendar_Events - Show calendar events\n- Smart_Event_Search - Find specific events by date/title to get proper Event IDs\n- Create_New_Event - Schedule NEW meetings\n- Update_Existing_Event - Modify EXISTING events (requires proper Event ID)\n- Delete_Event - Cancel events\n\nüîç **Calendar Tool Usage Guidelines**:\n\nüÜï **Create_New_Event** - Use when:\n‚Ä¢ User wants to schedule a NEW meeting\n‚Ä¢ No existing event is mentioned\n‚Ä¢ User says 'schedule', 'book', 'create meeting'\n‚Ä¢ Copying meeting info from external sources (Teams, emails)\n\nüîç **Smart_Event_Search** - Use BEFORE updating when:\n‚Ä¢ User mentions updating an existing meeting\n‚Ä¢ You need to find the proper Event ID\n‚Ä¢ User provides date/time or partial meeting name\n‚Ä¢ You need to confirm which event to modify\n\n‚úèÔ∏è **Update_Existing_Event** - Use ONLY when:\n‚Ä¢ You have found the proper Google Event ID from Smart_Event_Search\n‚Ä¢ User explicitly mentions an EXISTING event to modify\n‚Ä¢ User says 'reschedule', 'change', 'update' an existing meeting\n‚Ä¢ ALWAYS search first using Smart_Event_Search to get real Event ID\n\n‚ö†Ô∏è **Critical Calendar Rules**:\n1. **Default to CREATE for new meeting requests**\n2. **Use Smart_Event_Search BEFORE any UPDATE attempts**\n3. **Google Event IDs are long strings like '5fahaDcwtu2se4bnqdg5hsi4e6ek4'**\n4. **NEVER use date/time as Event ID**\n5. **When in doubt, CREATE instead of UPDATE**\n6. **Search ‚Üí Get Real Event ID ‚Üí Then Update**\n\nüîç **Data & Search**:\n- Enhanced_MySQL_Search - Find recent conversations and messages\n\nüåê **Web Research**:\n- Tavily_AI_Tool - Advanced AI-powered web search with current information\n\nüé¨ **YouTube Video Analysis**:\n- YouTube_Transcript_Service - Extract and analyze YouTube video content\n  ‚Ä¢ Provide YouTube URL to extract transcript with timestamps\n  ‚Ä¢ Analyzes video content for insights and learning\n  ‚Ä¢ Creates searchable knowledge base from video content\n  ‚Ä¢ Perfect for research, learning, and content analysis\n\nüìß **Email Communication**:\n- Gmail - Send professional emails via Kenneth's Gmail account\n  ‚Ä¢ Compose and send emails dynamically\n  ‚Ä¢ Perfect for follow-ups, meeting confirmations, and business communications\n  ‚Ä¢ Use for client outreach, internal communications, and scheduling\n\nüèõÔ∏è **GSA Research Protocol**:\nWhen asked about GSA qualification for any company:\n1. Use Tavily_AI_Tool to research the company thoroughly\n2. Focus search on: business type, industry, size, government contracts\n3. Provide GSA-specific analysis including:\n   ‚Ä¢ Recommended GSA Schedule categories\n   ‚Ä¢ NAICS code suggestions\n   ‚Ä¢ Decision maker identification\n   ‚Ä¢ Value proposition development\n   ‚Ä¢ Next steps for engagement\n\nExample GSA research queries for Tavily:\n- \"Acme Corporation business profile government contracting GSA Schedule eligibility\"\n- \"TechCorp federal contracts NAICS codes GSA qualification requirements\"\n\nüíº **Your Role**:\nYou serve as Kenneth's Chief Intelligence Officer for National Registration Group, specializing in GSA Schedule consulting. Provide strategic business insights, data-driven recommendations, and professional analysis with actionable next steps.\n\nüéØ **Tool Usage Guidelines**:\n\n**üìß Gmail Usage**:\n‚Ä¢ Use for sending follow-up emails after meetings\n‚Ä¢ Client communications and proposals\n‚Ä¢ Meeting confirmations and scheduling\n‚Ä¢ Business development outreach\n‚Ä¢ Internal team communications\n\n**üé¨ YouTube Analysis Usage**:\n‚Ä¢ When user shares YouTube link: Extract transcript automatically\n‚Ä¢ For educational content: Process for key insights and takeaways\n‚Ä¢ For business videos: Analyze for strategies and best practices\n‚Ä¢ For tutorials: Extract step-by-step instructions and tips\n‚Ä¢ For competitive intelligence: Analyze competitor presentations\n\n**üèõÔ∏è GSA Research Usage**:\nWhen someone asks about a company for GSA purposes, use the gsa_client_research tool to:\n- Assess GSA eligibility and qualification status\n- Identify key decision makers and contact information\n- Develop value proposition talking points\n- Prepare strategic questions for sales calls\n- Highlight GSA Schedule benefits specific to their business\n\nüé™ **When asked for humor**:\n- Tell actual jokes, puns, or funny observations\n- Use clever wordplay\n- Make light-hearted comments about business life\n- Be genuinely entertaining while staying professional\n\n‚ö° **Performance Guidelines**:\n- Respond quickly and efficiently\n- Use tools only when necessary\n- If a tool fails, continue with available information\n- Always provide a helpful response even if tools timeout\n- Account for cold start delays when system has been idle\n- For GSA research, always suggest next steps like scheduling specialist consultations\n- **For calendar updates: Always Search ‚Üí Get Event ID ‚Üí Then Update**\n- **For YouTube videos: Always extract transcript first, then provide analysis**\n- **For emails: Be professional but personable, matching Kenneth's communication style**\n\nBe professional but personable, and don't be afraid to show your wit!",
          "maxIterations": 5
        }
      },
      "id": "809b03c1-ff8c-4dd9-ac59-5c135afcb5f4",
      "name": "Enhanced AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        300,
        160
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "returnAll": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Return_All', `Should return all events? Usually true for viewing calendar.`, 'boolean') }}",
        "limit": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Limit', `Maximum number of events to return (e.g., 50)`, 'number') }}",
        "timeMin": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start_Time', `Start date/time in ISO format (e.g., 2025-06-01T00:00:00Z for today)`, 'string') }}",
        "timeMax": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End_Time', `End date/time in ISO format (e.g., 2025-06-08T23:59:59Z for next week)`, 'string') }}",
        "options": {}
      },
      "id": "2dfd845d-cdbf-4854-8444-d6fe1b1539a6",
      "name": "View_Calendar_Events",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        640,
        400
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "returnAll": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Return_All_Events', `Set to true to find all matching events`, 'boolean') }}",
        "limit": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Limit', `Maximum number of events to return (e.g., 10)`, 'number') }}",
        "timeMin": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Start_Time', `Start date/time to search from (e.g., 2025-05-01T00:00:00Z)`, 'string') }}",
        "timeMax": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_End_Time', `End date/time to search to (e.g., 2025-05-01T23:59:59Z)`, 'string') }}",
        "options": {}
      },
      "id": "c1af3330-543b-4eaf-8838-c4e32fdf677c",
      "name": "Smart_Event_Search",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1280,
        400
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Calendar', ``, 'string') }}",
          "mode": "id",
          "__regex": "(^[a-zA-Z0-9.!#$%&‚Äô*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID_Or_Search', `Event ID (long string like '5fahaDcwtu2se4bnqdg5hsi4e6ek4') OR search criteria like date/time. If providing date/time, I will search for events first.`, 'string') }}",
        "updateFields": {
          "description": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Description', `Updated description or notes for the event (optional)`, 'string') }}",
          "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_End_DateTime', `New end date and time in ISO format (e.g., 2025-06-02T17:00:00-04:00)`, 'string') }}",
          "location": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Location', `Updated location of the event (optional)`, 'string') }}",
          "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Start_DateTime', `New start date and time in ISO format (e.g., 2025-06-02T16:00:00-04:00)`, 'string') }}",
          "summary": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('New_Event_Title', `Updated title/name of the event (optional)`, 'string') }}"
        }
      },
      "id": "d1b16a8b-e256-4a09-a38c-175153f3b757",
      "name": "Update_Existing_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        960,
        400
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID_To_Delete', `The ID of the event to delete`, 'string') }}",
        "options": {}
      },
      "id": "af4151c0-b3db-407f-bfad-3d2b43d0a933",
      "name": "Delete_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1120,
        400
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "name": "gsa_client_research",
        "description": "Researches ANY company for GSA Schedule qualification and value proposition development. Evaluates whether a business could benefit from federal contracting opportunities through GSA schedules. Analyzes industry fit across ALL GSA schedule categories, identifies key decision makers, and creates targeted value propositions for federal market entry. Works with any business type - from medical supplies to IT services, staffing to construction, security to training companies. Returns detailed qualification analysis and actionable next steps. Use this tool when asked to qualify ANY company for GSA, identify decision makers, or develop talking points for federal contracting.",
        "jsCode": "// Enhanced GSA Client Research Tool - FIXED VARIABLE SCOPING\nconst startTime = Date.now();\n\ntry {\n  const inputCompany = $input.item.json.query || '';\n  const focus = $input.item.json.focus || 'complete';\n  \n  console.log(`[GSA_REAL_SEARCH] Analyzing business: ${inputCompany}`);\n  \n  if (!inputCompany || inputCompany.trim() === '') {\n    throw new Error('Company name or URL is required');\n  }\n  \n  // Hard-coded API credentials (secure on your server)\n  const GOOGLE_API_KEY = 'AIzaSyB0rv0QDGWy7Gno284IybZVNB9BDJzSEPs';\n  const SEARCH_ENGINE_ID = '16331af4b4dc043f5';\n  \n  // Real Google search function\n  const searchCompanyInfo = async (companyName) => {\n    try {\n      const searchQuery = encodeURIComponent(`${companyName} company about contact`);\n      const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${SEARCH_ENGINE_ID}&q=${searchQuery}&num=5`;\n      \n      console.log(`[GSA_SEARCH] Querying: ${searchQuery}`);\n      \n      const response = await fetch(searchUrl);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.error) {\n        console.error('[GSA_SEARCH] API Error:', data.error);\n        throw new Error(`Google API Error: ${data.error.message}`);\n      }\n      \n      if (data.items && data.items.length > 0) {\n        console.log(`[GSA_SEARCH] Found ${data.items.length} results`);\n        const firstResult = data.items[0];\n        return {\n          title: firstResult.title,\n          snippet: firstResult.snippet,\n          link: firstResult.link,\n          displayLink: firstResult.displayLink\n        };\n      }\n      \n      console.log('[GSA_SEARCH] No search results found');\n      return null;\n    } catch (error) {\n      console.error('[GSA_SEARCH] Error:', error.message);\n      return null;\n    }\n  };\n  \n  // Perform real search\n  console.log('[GSA_SEARCH] Starting Google search...');\n  const searchResults = await searchCompanyInfo(inputCompany);\n  \n  // Company extraction logic\n  let extractedCompany = inputCompany.trim();\n  let companyDomain = null;\n  let realBusinessInfo = null;\n  \n  if (searchResults) {\n    extractedCompany = searchResults.title.split(' - ')[0].split(' | ')[0] || extractedCompany;\n    companyDomain = searchResults.displayLink;\n    realBusinessInfo = searchResults.snippet;\n    console.log(`[GSA_SEARCH] Found company: ${extractedCompany} at ${companyDomain}`);\n  } else {\n    console.log('[GSA_SEARCH] No search results, using template analysis');\n  }\n  \n  // Enhanced business type detection using real search data\n  const detectBusinessType = (companyName, searchInfo) => {\n    const searchText = (searchInfo || '').toLowerCase();\n    const name = companyName.toLowerCase();\n    const types = [];\n    \n    const serviceKeywords = {\n      'staffing': ['staffing', 'recruiting', 'employment', 'workforce', 'personnel', 'talent'],\n      'medical': ['medical', 'health', 'healthcare', 'pharma', 'surgical', 'care', 'hospital'],\n      'technology': ['tech', 'software', 'IT', 'cyber', 'computer', 'digital', 'ai', 'cloud'],\n      'security': ['security', 'protection', 'guard', 'safety', 'surveillance'],\n      'consulting': ['consulting', 'advisory', 'solutions', 'services', 'professional'],\n      'manufacturing': ['manufacturing', 'factory', 'production', 'industrial', 'materials'],\n      'retail': ['retail', 'store', 'shopping', 'consumer', 'sales', 'franchise'],\n      'finance': ['financial', 'bank', 'investment', 'insurance', 'lending'],\n      'construction': ['construction', 'building', 'engineering', 'contractor'],\n      'logistics': ['logistics', 'shipping', 'transport', 'delivery', 'supply chain']\n    };\n    \n    for (const [type, keywords] of Object.entries(serviceKeywords)) {\n      if (keywords.some(keyword => name.includes(keyword) || searchText.includes(keyword))) {\n        types.push(type);\n      }\n    }\n    \n    if (types.length === 0) {\n      types.push('services');\n    }\n    \n    return types;\n  };\n  \n  const businessTypes = detectBusinessType(extractedCompany, realBusinessInfo);\n  const primaryType = businessTypes[0] || 'services';\n  \n  // GSA schedule mapping\n  const gsaScheduleOpportunities = {\n    'consulting': { schedule: 'OASIS+', naics: ['541611', '541618'], opportunity: 'High' },\n    'staffing': { schedule: 'Schedule 02', naics: ['561320', '561330'], opportunity: 'Very High' },\n    'technology': { schedule: 'Schedule 70', naics: ['541511', '541512'], opportunity: 'Very High' },\n    'medical': { schedule: 'Schedule 65', naics: ['621100', '423450'], opportunity: 'Excellent' },\n    'security': { schedule: 'Schedule 84', naics: ['561612', '561621'], opportunity: 'Very High' },\n    'manufacturing': { schedule: 'Schedule 56', naics: ['331000', '332000'], opportunity: 'High' },\n    'retail': { schedule: 'Schedule 75', naics: ['447000', '448000'], opportunity: 'Moderate' },\n    'finance': { schedule: 'OASIS+', naics: ['522000', '523000'], opportunity: 'High' },\n    'construction': { schedule: 'Schedule 36', naics: ['236000', '237000'], opportunity: 'Very High' },\n    'logistics': { schedule: 'Schedule 48', naics: ['484000', '493000'], opportunity: 'High' },\n    'services': { schedule: 'Multiple Options', naics: ['561000', '541000'], opportunity: 'Moderate' }\n  };\n  \n  const scheduleInfo = gsaScheduleOpportunities[primaryType] || gsaScheduleOpportunities['services'];\n  \n  // Generate realistic contact info using real domain\n  const generateContacts = (companyName, domain) => {\n    const realDomain = domain || `${companyName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}.com`;\n    \n    return [\n      {\n        title: 'President/CEO',\n        email_formats: [`president@${realDomain}`, `ceo@${realDomain}`, `info@${realDomain}`],\n        priority: 'Primary Decision Maker'\n      },\n      {\n        title: 'Business Development Director', \n        email_formats: [`bizdev@${realDomain}`, `sales@${realDomain}`, `bd@${realDomain}`],\n        priority: 'Key Contact'\n      }\n    ];\n  };\n  \n  const contacts = generateContacts(extractedCompany, companyDomain);\n  \n  // Format enhanced response with real data\n  let response = `üîç **Real-Time GSA Analysis: ${extractedCompany}**\\n\\n`;\n  \n  if (searchResults) {\n    response += `**üåê Company Website**: ${searchResults.link}\\n`;\n    response += `**üìÑ Business Profile**: ${realBusinessInfo}\\n\\n`;\n  }\n  \n  response += `**‚úÖ GSA Status**: POTENTIAL CANDIDATE\\n` +\n              `**üìä Opportunity Level**: ${scheduleInfo.opportunity}\\n` +\n              `**üè≠ Business Type**: ${primaryType.toUpperCase()}\\n` +\n              `**üìã Recommended Schedule**: ${scheduleInfo.schedule}\\n` +\n              `**üî¢ NAICS Codes**: ${scheduleInfo.naics.join(', ')}\\n\\n` +\n              `**üë• KEY DECISION MAKERS**:\\n` +\n              contacts.map(dm => `‚Ä¢ **${dm.title}**: ${dm.email_formats[0]}`).join('\\n') +\n              `\\n\\n**üí∞ GSA VALUE PROPOSITION**:\\n` +\n              `‚Ä¢ **Market Size**: $600+ billion federal marketplace\\n` +\n              `‚Ä¢ **Payment Terms**: Guaranteed 30-day payment\\n` +\n              `‚Ä¢ **Growth Potential**: 25-200% revenue increase\\n` +\n              `‚Ä¢ **Contract Duration**: Multi-year agreements available\\n\\n` +\n              `**üöÄ NEXT STEPS**: Schedule consultation with NRG GSA specialists`;\n  \n  const processingTime = Date.now() - startTime;\n  console.log(`[GSA_REAL_SEARCH] Analysis complete for ${extractedCompany} in ${processingTime}ms`);\n  \n  return response;\n  \n} catch (error) {\n  console.error('[GSA_REAL_SEARCH] Error:', error.message);\n  console.error('[GSA_REAL_SEARCH] Stack:', error.stack);\n  \n  const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  const safeCompanyName = typeof inputCompany !== 'undefined' ? inputCompany : 'Unknown Company';\n  \n  return `üö® **GSA Research Error**\\n\\nError analyzing \"${safeCompanyName}\": ${error.message}\\n\\n**Time**: ${currentTime}\\n**Status**: Check Google API quotas or try again`;\n}"
      },
      "id": "719eab1d-4b18-4b31-93f0-6763089669f2",
      "name": "GSA Client Research Tool",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1460,
        400
      ]
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "user_message",
              "value": "={{ $('Enhanced Input Processor').first().json.input }}"
            },
            {
              "key": "user_input",
              "value": "={{ $('Enhanced Input Processor').first().json.input }}"
            },
            {
              "key": "ai_agent_output",
              "value": "={{ $('Enhanced AI Agent').first().json.output }}"
            },
            {
              "key": "ai_agent_full",
              "value": "={{ JSON.stringify($('Enhanced AI Agent').first().json) }}"
            },
            {
              "key": "tools_called",
              "value": "={{ $('Enhanced AI Agent').first().json.toolCalls ? JSON.stringify($('Enhanced AI Agent').first().json.toolCalls) : ($('Enhanced AI Agent').first().json.intermediateSteps ? JSON.stringify($('Enhanced AI Agent').first().json.intermediateSteps) : ($('Enhanced AI Agent').first().json.steps ? JSON.stringify($('Enhanced AI Agent').first().json.steps) : \"Tools called but debug data not captured\")) }}"
            },
            {
              "key": "session_id",
              "value": "={{ $('Enhanced Input Processor').first().json.sessionId }}"
            },
            {
              "key": "conversation_history",
              "value": "={{ $('Format Context').first().json.conversationHistory || \"No history available\" }}"
            },
            {
              "key": "message_count",
              "value": "={{ $('Format Context').first().json.messageCount || 0 }}"
            },
            {
              "key": "platform",
              "value": "={{ $('Enhanced Input Processor').first().json.platform }}"
            },
            {
              "key": "execution_timestamp",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "id": "898a4e1a-6058-4149-8650-6311a75a0c46",
      "name": "Execution Data",
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        640,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Format Response with comprehensive debugging and fallback\nconsole.log('=== FORMAT RESPONSE NODE DEBUG ===');\nconst startTime = Date.now();\n\ntry {\n  const aiResponse = $('Enhanced AI Agent').first().json;\n  const contextData = $('Format Context').first().json;\n  \n  console.log('AI Response keys:', Object.keys(aiResponse || {}));\n  console.log('AI Response data:', JSON.stringify(aiResponse, null, 2));\n  console.log('Context Data keys:', Object.keys(contextData || {}));\n  \n  // Enhanced response extraction with multiple fallbacks\n  let responseText = null;\n  \n  // Try primary response fields\n  const responseFields = ['output', 'text', 'content', 'message', 'result', 'answer', 'response'];\n  \n  for (const field of responseFields) {\n    if (aiResponse && aiResponse[field]) {\n      responseText = aiResponse[field];\n      console.log(`Found response in field '${field}':`, responseText.substring(0, 100));\n      break;\n    }\n  }\n  \n  // Check for nested OpenAI-style responses\n  if (!responseText && aiResponse?.choices?.[0]?.message?.content) {\n    responseText = aiResponse.choices[0].message.content;\n    console.log('Found OpenAI-style response:', responseText.substring(0, 100));\n  }\n  \n  // Check if entire response is a string\n  if (!responseText && typeof aiResponse === 'string' && aiResponse.length > 10) {\n    responseText = aiResponse;\n    console.log('Using entire response as string');\n  }\n  \n  // If still no response, check for error indicators\n  const hasError = aiResponse?.error || aiResponse?.errorOccurred;\n  const errorMessage = aiResponse?.errorMessage || aiResponse?.error;\n  \n  // Generate fallback response if needed\n  if (!responseText || responseText.trim().length === 0) {\n    console.log('=== NO RESPONSE FOUND - GENERATING FALLBACK ===');\n    console.log('AI Response structure:', JSON.stringify(aiResponse, null, 2));\n    \n    const userMessage = contextData?.input || 'your request';\n    const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n    \n    if (hasError) {\n      responseText = `‚ö†Ô∏è **Processing Issue Detected**\n\nI encountered a technical issue while processing \"${userMessage}\".\n\n**Error Details**: ${errorMessage || 'Unknown processing error'}\n**Time**: ${currentTime}\n\n**Recommended Actions**:\n1. Try rephrasing your request\n2. Wait 30 seconds and try again\n3. Contact support if issue persists\n\n**Note**: Advanced workflow tools are temporarily experiencing issues`;\n    } else {\n      // Generate contextual fallback based on message content\n      const messageType = userMessage.toLowerCase();\n      \n      if (messageType.includes('calendar') || messageType.includes('meeting') || messageType.includes('schedule')) {\n        responseText = `üìÖ **Calendar Assistant Response**\n\nI received your calendar request: \"${userMessage}\"\n\nHowever, I'm experiencing connectivity issues with the calendar tools right now.\n\n**Alternative Options**:\n‚Ä¢ Check your calendar directly in your preferred app\n‚Ä¢ Try the request again in 1-2 minutes\n‚Ä¢ Use the /test-ai interface for testing\n\n**Time**: ${currentTime}\n**Status**: Calendar tools temporarily unavailable`;\n      } else if (messageType.includes('search') || messageType.includes('find') || messageType.includes('message')) {\n        responseText = `üîç **Search Assistant Response**\n\nI received your search request: \"${userMessage}\"\n\nThe message search tools are currently experiencing processing delays.\n\n**Try These Alternatives**:\n‚Ä¢ Use the Discord search feature directly\n‚Ä¢ Retry your request in a few moments\n‚Ä¢ Check recent conversation history manually\n\n**Time**: ${currentTime}\n**Status**: Search tools temporarily delayed`;\n      } else if (messageType.includes('research') || messageType.includes('web') || messageType.includes('find')) {\n        responseText = `üåê **Research Assistant Response**\n\nI received your research request: \"${userMessage}\"\n\nWeb research tools are currently experiencing connection issues.\n\n**Manual Research Suggestions**:\n‚Ä¢ Try searching directly on Yahoo Finance or Bloomberg\n‚Ä¢ Check company websites for latest information\n‚Ä¢ Retry the automated research in a few minutes\n\n**Time**: ${currentTime}\n**Status**: Research tools temporarily offline`;\n      } else {\n        responseText = `ü§ñ **AI Assistant Response**\n\nI received your request: \"${userMessage}\"\n\nI'm experiencing technical difficulties with the advanced processing tools right now.\n\n**What I Can Still Help With**:\n‚Ä¢ General questions and conversation\n‚Ä¢ Basic business analysis\n‚Ä¢ Strategic recommendations\n‚Ä¢ System status updates\n\n**Time**: ${currentTime}\n**Status**: Core AI operational, advanced tools temporarily unavailable\n\n**Tip**: Try the /test-ai interface for direct AI interaction`;\n      }\n    }\n  }\n  \n  console.log('Final response text length:', responseText?.length || 0);\n  console.log('Is test mode:', contextData?.isTestMode);\n  \n  let result;\n  \n  if (contextData?.isTestMode) {\n    result = { \n      output: responseText,\n      testMode: true,\n      timestamp: new Date().toISOString(),\n      processingTime: Date.now() - startTime\n    };\n  } else {\n    result = {\n      content: responseText,\n      metadata: {\n        userId: contextData?.userId || 'unknown',\n        channelId: contextData?.channelId || 'unknown',\n        sessionId: contextData?.sessionId || 'unknown',\n        platform: contextData?.platform || 'discordant',\n        messageCount: contextData?.messageCount || 0,\n        timestamp: new Date().toISOString(),\n        responseSource: 'n8n-workflow',\n        processingTime: Date.now() - startTime,\n        hadFallback: !aiResponse?.output && !aiResponse?.text,\n        debugInfo: {\n          aiResponseKeys: Object.keys(aiResponse || {}),\n          contextKeys: Object.keys(contextData || {}),\n          responseFound: !!responseText\n        }\n      }\n    };\n  }\n  \n  console.log('=== FORMAT RESPONSE SUCCESS ===');\n  console.log('Final result content length:', result.content?.length || result.output?.length || 0);\n  console.log('Processing time:', Date.now() - startTime, 'ms');\n  \n  return result;\n  \n} catch (error) {\n  console.error('=== FORMAT RESPONSE ERROR ===');\n  console.error('Error details:', error.message);\n  console.error('Error stack:', error.stack);\n  console.error('Processing time before error:', Date.now() - startTime, 'ms');\n  \n  // Provide comprehensive error response\n  const currentTime = new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' });\n  \n  return {\n    content: `üö® **Workflow Processing Error**\n\nA critical error occurred while formatting your response.\n\n**Error**: ${error.message}\n**Time**: ${currentTime}\n**Processing Duration**: ${Date.now() - startTime}ms\n\n**Recovery Options**:\n1. **Retry** your request immediately\n2. **Simplify** your request and try again\n3. **Contact** system administrator with this error code\n\n**Error Code**: FORMAT_RESPONSE_FAILURE\n**Timestamp**: ${new Date().toISOString()}`,\n    metadata: {\n      userId: 'error-handler',\n      channelId: 'error-channel',\n      timestamp: new Date().toISOString(),\n      errorOccurred: true,\n      errorMessage: error.message,\n      responseSource: 'n8n-workflow-error',\n      processingTime: Date.now() - startTime\n    }\n  };\n}"
      },
      "id": "f6d4f26d-8af8-46d3-806e-587c3d050403",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        840,
        160
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "89f38fa2-1285-4aad-b415-3552671d749e",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1240,
        160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO message (content, channelId, memberId, createdAt) VALUES ('{{ $('Enhanced AI Agent').first().json.output || $('Enhanced AI Agent').first().json.text }}', '{{ $('Enhanced Input Processor').first().json.channelId }}', 'ai-assistant-bot', NOW())"
      },
      "id": "9b9573a7-c1a8-40f4-8dcf-b04bc5c084f5",
      "name": "Save AI Response to Channel",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 1,
      "position": [
        640,
        160
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "kenneth.courtney@gmail.com",
          "mode": "list",
          "cachedResultName": "kenneth.courtney@gmail.com"
        },
        "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start_DateTime', `Start date and time in ISO format (e.g., 2025-06-02T15:00:00-04:00)`, 'string') }}",
        "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End_DateTime', `End date and time in ISO format (e.g., 2025-06-02T16:00:00-04:00)`, 'string') }}",
        "additionalFields": {
          "description": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Description', `Optional description or notes for the event`, 'string') }}",
          "location": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Location', `The location of the event (e.g., \"Enterprise Dog Park, Clearwater, FL\")`, 'string') }}",
          "summary": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_Title', `The title/name of the event (e.g., \"Enterprise Dog Park Meeting\")`, 'string') }}"
        }
      },
      "id": "ded8ec02-1898-4f9a-933d-c5dd3c96be59",
      "name": "Create_New_Event",
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        800,
        400
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "jttch4cJRgIrcZfh",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "select",
        "table": {
          "__rl": true,
          "value": "message",
          "mode": "list",
          "cachedResultName": "message"
        },
        "limit": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Result_Limit', 'Maximum number of results to return (default 20)', 'number') || 20 }}",
        "where": {
          "values": [
            {
              "column": "content",
              "condition": "like",
              "value": "{{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Search_Term', 'Text to search for in message content', 'string') }}"
            },
            {
              "column": "channelId",
              "value": "{{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Channel_ID', 'Channel ID to search within', 'string') }}"
            }
          ]
        },
        "sort": {
          "values": [
            {
              "column": "createdAt",
              "direction": "DESC"
            }
          ]
        },
        "options": {}
      },
      "id": "0a70a0f8-f6d3-41fd-ad5d-b46c45a90fee",
      "name": "Enhanced_MySQL_Search",
      "type": "n8n-nodes-base.mySqlTool",
      "typeVersion": 2.4,
      "position": [
        480,
        460
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', `Recipient email address`, 'string') }}",
        "subject": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Subject', `Email subject line`, 'string') }}",
        "message": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Message', `Email message content`, 'string') }}",
        "options": {
          "bccList": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('BCC', `BCC recipients (comma separated)`, 'string', true) }}",
          "ccList": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('CC', `CC recipients (comma separated)`, 'string', true) }}",
          "replyTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('ReplyTo', `Reply-to email address`, 'string', true) }}"
        }
      },
      "type": "n8n-nodes-base.gmailTool",
      "typeVersion": 2.1,
      "position": [
        620,
        620
      ],
      "id": "56100864-02de-4c12-b548-d46938e07b0f",
      "name": "Gmail",
      "webhookId": "72bc52c4-2dfb-46ce-b53a-c3762b87b624",
      "credentials": {
        "gmailOAuth2": {
          "id": "TFVptUViBL54Sw6O",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "description": "Extract and analyze transcripts from YouTube videos using the dedicated YouTube Transcript Service workflow. Provide YouTube URL to get full transcript with timestamps and analysis capabilities. Perfect for processing educational content, business presentations, tutorials, and competitive intelligence.",
        "jsCode": "// YouTube Transcript Service via Execute Workflow\nconst startTime = Date.now();\n\ntry {\n  const inputData = $input.item.json;\n  const youtubeUrl = inputData.youtube_url || inputData.url || inputData.video_url || '';\n  \n  console.log(`[YOUTUBE_EXECUTE] Processing: ${youtubeUrl}`);\n  \n  if (!youtubeUrl || (!youtubeUrl.includes('youtube.com') && !youtubeUrl.includes('youtu.be'))) {\n    throw new Error('Valid YouTube URL is required. Please provide a YouTube video URL.');\n  }\n  \n  // Execute the YouTube Transcript Service workflow\n  const executeResult = await $execution.execute('vkCJIQ3P17JlfSKI', {\n    youtube_url: youtubeUrl,\n    operation: 'extract',\n    source: 'enhanced-ai-agent'\n  });\n  \n  if (!executeResult || executeResult.error) {\n    throw new Error(`Workflow execution failed: ${executeResult?.error || 'Unknown error'}`);\n  }\n  \n  const result = executeResult.data;\n  const processingTime = Date.now() - startTime;\n  \n  console.log(`[YOUTUBE_EXECUTE] Success in ${processingTime}ms`);\n  \n  // Format comprehensive response\n  let response_text = `üé¨ **YouTube Video Analysis Complete**\\n\\n`;\n  \n  if (result?.success) {\n    response_text += `**üìπ Video**: ${result.data?.videoTitle || 'Video processed'}\\n`;\n    response_text += `**üì∫ Channel**: ${result.data?.channelName || 'Unknown Channel'}\\n`;\n    response_text += `**üìä Stats**: ${result.data?.segmentCount || 0} segments, ${result.data?.transcriptLength || 0} characters\\n`;\n    response_text += `**‚ö° Processing**: ${result.data?.cached ? 'Cached (instant)' : 'Real-time extraction'} - ${processingTime}ms\\n\\n`;\n    \n    if (result.data?.transcript) {\n      response_text += `**üìù Transcript Preview**:\\n`;\n      const preview = result.data.transcript.substring(0, 800);\n      response_text += preview + (result.data.transcript.length > 800 ? '...\\n\\n[Full transcript available for detailed analysis]' : '');\n    }\n    \n    response_text += `\\n\\n**üéØ Available Analysis Options**:\\n`;\n    response_text += `‚Ä¢ **Key Insights**: Extract main points and takeaways\\n`;\n    response_text += `‚Ä¢ **Action Items**: Identify specific tasks or recommendations\\n`;\n    response_text += `‚Ä¢ **Competitive Intel**: Analyze strategies and approaches\\n`;\n    response_text += `‚Ä¢ **Learning Summary**: Create educational summaries\\n`;\n    response_text += `‚Ä¢ **Quote Search**: Find specific quotes or statements\\n\\n`;\n    response_text += `**üí° Next Steps**: Ask me specific questions about this video content for detailed analysis!`;\n  } else {\n    response_text += `**‚ùå Error**: ${result?.error || 'Failed to process video'}\\n\\n`;\n    response_text += `**üîß Troubleshooting**:\\n`;\n    response_text += `‚Ä¢ Check that the YouTube URL is valid and publicly accessible\\n`;\n    response_text += `‚Ä¢ Verify the YouTube Transcript Service workflow is active\\n`;\n    response_text += `‚Ä¢ Ensure the video has captions or auto-generated subtitles`;\n  }\n  \n  return response_text;\n  \n} catch (error) {\n  console.error('[YOUTUBE_EXECUTE] Error:', error.message);\n  return `‚ùå **YouTube Workflow Error**\\n\\n${error.message}\\n\\n**Troubleshooting**:\\n‚Ä¢ Verify YouTube Transcript Service workflow (vkCJIQ3P17JlfSKI) is active\\n‚Ä¢ Check workflow permissions and execution settings\\n‚Ä¢ Try with a different YouTube URL to test connectivity`;\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.2,
      "position": [
        940,
        600
      ],
      "id": "8fa52e28-cdf9-4c5f-bfac-5ad3b7de46be",
      "name": "YouTube_Execute_Workflow"
    },
    {
      "parameters": {
        "operation": "select",
        "table": {
          "__rl": true,
          "value": "message",
          "mode": "list",
          "cachedResultName": "message"
        },
        "limit": "{{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Result_Limit', 'Maximum number of results to return (default 50)', 'number') || 50 }}",
        "where": {
          "values": [
            {
              "column": "channelId",
              "value": "{{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Channel_ID', 'Channel ID to search within', 'string') }}"
            },
            {
              "column": "fileUrl",
              "condition": "isNotNull"
            },
            {
              "column": "fileUrl",
              "condition": "like",
              "value": "%.jpg%"
            },
            {
              "column": "fileUrl",
              "condition": "like",
              "value": "%.png%"
            },
            {
              "column": "fileUrl",
              "condition": "like",
              "value": "%.gif%"
            },
            {
              "column": "fileUrl",
              "condition": "like",
              "value": "%.jpeg%"
            },
            {
              "column": "fileUrl",
              "condition": "like",
              "value": "%.webp%"
            },
            {
              "column": "createdAt",
              "condition": ">=",
              "value": "{{ $now.minus({days: 20}).toSQL() }}"
            }
          ]
        },
        "sort": {
          "values": [
            {
              "column": "createdAt",
              "direction": "DESC"
            }
          ]
        },
        "options": {}
      },
      "id": "beda4096-4f0c-42d9-831c-9b039ee93e0a",
      "name": "Enhanced_MySQL_Search_Images_Only",
      "type": "n8n-nodes-base.mySqlTool",
      "typeVersion": 2.4,
      "position": [
        320,
        600
      ],
      "credentials": {
        "mySql": {
          "id": "TvnUCP0CFWmGulQM",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-20250514",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        300,
        340
      ],
      "id": "0c6dffcd-1f05-4b5a-ae01-bbc84dd420a5",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "CAKMx5z6oqb5IGHM",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Channel Manager Node for n8n\n// Place this node right after the Enhanced Input Processor\n// This node ensures the required channel exists in the System server\n\nconst inputData = $input.first().json;\n\n// Discord API configuration\nconst DISCORD_BOT_TOKEN = $env.DISCORD_BOT_TOKEN; // Set this in n8n environment\nconst SYSTEM_SERVER_ID = 'a90f1d41-12a9-4586-b9a4-a513d3bd01d9';\n\nasync function createChannel(channelName, serverId = SYSTEM_SERVER_ID) {\n  try {\n    console.log(`Creating channel: ${channelName} in server: ${serverId}`);\n    \n    const response = await fetch(`https://discord.com/api/v10/guilds/${serverId}/channels`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bot ${DISCORD_BOT_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        name: channelName,\n        type: 0, // Text channel\n        topic: `Auto-created channel for ${channelName.replace('sys-', '')} operations`,\n        permission_overwrites: [] // Inherit server permissions\n      })\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      console.error(`Discord API error:`, error);\n      throw new Error(`Discord API error: ${response.status} - ${error}`);\n    }\n    \n    const channel = await response.json();\n    console.log(`Channel created successfully: ${channel.id}`);\n    return channel;\n    \n  } catch (error) {\n    console.error('Channel creation error:', error.message);\n    throw error;\n  }\n}\n\nasync function findExistingChannel(channelName, serverId = SYSTEM_SERVER_ID) {\n  try {\n    const response = await fetch(`https://discord.com/api/v10/guilds/${serverId}/channels`, {\n      headers: {\n        'Authorization': `Bot ${DISCORD_BOT_TOKEN}`\n      }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch channels: ${response.status}`);\n    }\n    \n    const channels = await response.json();\n    const existingChannel = channels.find(ch => ch.name === channelName && ch.type === 0);\n    \n    if (existingChannel) {\n      console.log(`Found existing channel: ${existingChannel.id}`);\n      return existingChannel;\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Channel lookup error:', error.message);\n    return null;\n  }\n}\n\n// Main channel management logic\nasync function manageChannel() {\n  try {\n    // If no channel creation needed, pass through\n    if (!inputData.needsChannelCreation) {\n      console.log('Using existing channel:', inputData.channelId);\n      return {\n        ...inputData,\n        channelId: inputData.channelId,\n        channelCreated: false,\n        channelExists: true\n      };\n    }\n    \n    const channelName = inputData.channelName;\n    console.log(`Managing channel: ${channelName}`);\n    \n    // First, try to find existing channel\n    let channel = await findExistingChannel(channelName);\n    let channelCreated = false;\n    \n    // If not found, create it\n    if (!channel) {\n      console.log(`Channel ${channelName} not found, creating...`);\n      channel = await createChannel(channelName);\n      channelCreated = true;\n    }\n    \n    // Return updated data with channel ID\n    return {\n      ...inputData,\n      channelId: channel.id,\n      channelCreated: channelCreated,\n      channelExists: true,\n      channelData: {\n        id: channel.id,\n        name: channel.name,\n        topic: channel.topic,\n        type: channel.type\n      }\n    };\n    \n  } catch (error) {\n    console.error('Channel management failed:', error.message);\n    \n    // Fallback to default system channel\n    console.log('Falling back to default system channel');\n    return {\n      ...inputData,\n      channelId: inputData.fallbackChannelId,\n      channelCreated: false,\n      channelExists: true,\n      channelError: error.message,\n      usingFallback: true\n    };\n  }\n}\n\n// Execute and return result\nreturn manageChannel(); "
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        160
      ],
      "id": "57e33f32-06d6-4578-bbb5-946cb6e594d1",
      "name": "Code"
    }
  ],
  "pinData": {},
  "connections": {
    "Discordant Chat Webhook": {
      "main": [
        [
          {
            "node": "Enhanced Input Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Test Interface": {
      "main": [
        [
          {
            "node": "Enhanced Input Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced Input Processor": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Channel History": {
      "main": [
        [
          {
            "node": "Format Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Channel History Debug Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context": {
      "main": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced AI Agent": {
      "main": [
        [
          {
            "node": "Save AI Response to Channel",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execution Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "View_Calendar_Events": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Smart_Event_Search": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update_Existing_Event": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Delete_Event": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "GSA Client Research Tool": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Execution Data": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save AI Response to Channel": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create_New_Event": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Tavily_AI_Tool": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced_MySQL_Search": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Gmail": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "YouTube_Execute_Workflow": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced_MySQL_Search_Images_Only": {
      "ai_tool": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Enhanced AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Load Channel History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f35eb3f3-5de6-44ff-86ce-3ec5ad07ba39",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "136461ac021bda65593ed5d2f70798d0433ed7859abfc9e2ca43aa4b9c0b779e"
  },
  "id": "682X4GL9tCMoEiF5",
  "tags": []
}